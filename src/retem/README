= Templating with retem

Since a web framework should have a templating feature, one should be implemented
for reia. Why not use existing? Just for fun, first. Just to improve and make it 
convenient and provide all the features that should be in out of the box:

* variables
* flow control
* filtering
* i18n
* nesting

It should probably look like:

Total {apples|count:~apples}
{for apple in apples} {apple.color apple.weight|kg}{end}

And this template will be rendered to:

Total 2 apples
red 0.2kg
yellow 0.15kg

== Building

== Usage

template = """Total {apples|count:~apples}
{for apple in apples} {apple.color apple.weight|kg} {end}"""

apples = [{~color: 'red', ~weight: 0.2}, {~color: 'yellow', ~weight: 0.15}]
Retem.i18n('apps/my_app/i18n.yaml')
rendered = Retem.render(template, {~apples, apples})

== Flow control

The simplest branching construct available is the if statement, which takes the specified branch if the condition holds true:

{if condition}
 ... 
{end}

Condition can consist of multiple conditions:

{if condition1 and condition2}...{end}
{if condition1 or condition2}...{end}

Condition can be a result of comparsion:
{if bees_count gt flowers_count}...{end}

The following comparsion operators can be used:

* eq  equal to
* neq not equal to
* gt greater than
* lt less than
* gteq greater than or equal to
* lteq less than or equal to

It is possible to use these kind of constructions:
{if a gt 3 or b lt 10}...{end}

The else keyword specifies an action to be taken if the condition doesn't match:

{if condition}
  ...
{else}
  ...
{end}

Multiple if statements can be chained with the elseif keyword:

{if condition1}
  ...
{elseif condition2}
  ...
{end}

This can be used with else, too:

{if condition1}
  ...
{elseif condition2}
  ...
{else}
  ...
{end}

The unless keyword functions like the if keyword, except expression matching is inverted and the branch is taken if the condition does not hold.

{unless condition}
  ...
{end}

For loops can iterate lists:

{for x in mylist}
  {x*2}
{end}

Pattern matching can be used when iterating lists of objects.
When iterating a list of lists:
mylist = [['aaa', 123], ['qqq', 456]]
{for [a,b] in mylist}
  {a} {b}
{end}

When iterating a list of tuples:
mylist = [('aaa', 123, ~first), ('qqq', 456, ~second)]
{for (a,b,c) in mylist}
  {a} {b} {c}
{end}

When iterating a list of dicts/objects:
apples = [{~color: 'red', ~weight: 0.2}, {~color: 'yellow', ~weight: 0.15}]
{for {color: ~color, weight: ~weight} in apples}
  Color is {color} and weight is {weight}
{end}

== Access to variables

Variables passed to retem can be freely used in templates:

{apple}

{apple.color}

{store.address.city}

== Filtering

Filtering allows for value modification, formatting etc. Filter signature comes after '|' character.
Filter parameters are passed after ':' character. Multiple parameters can be passed using ',' character.
For those parameters that can be treaten erratic, single quoting can be used.

The following examples are self-explaining, taking into account that a is a variable being passed:

a='apPles'
{a|capital}
>> ApPles

a='apPles'
{a|lower}
>> apples

a='apPles'
{a|upper}
>> APPLES

a='app_les'
{a|pretty}
>> App les

a='apple'
{a|plural}
>> apples

a='apples'
{a|singular}
>> apple

a='apples'
{a|length}
>> 6

a='*apple*'
{a|textile}
>> <b>apple</b>

a='/apple/'
{a|textile}
>> <i>apple</i>

a=123
{a|format:n.3}
>> 123.000

a=123
{a|format:n4.3}
>> 0123.000

a=Time.now
{a|format:dd-MM-yy/hh:mm:ss}
>> 11-11-2008/02:31:14

a='<h1>header</h1>'
{a|escape}
>> &lt;h1&gt;header&lt;/h1&gt;

a='a long long long string'
{a|cut:15}
>> a long long ...
{a|cut:30}
>> a long long long string

a=['apple', 'banana', 'coconut']
{a|count}
>> 3

a=['humour', 'life', 'friends']
Tags: {a|join:' '}
>> Tags: humour life friends

Filters can take several parameters:
a=['humour', 'life', 'friends']
{a|wrap:(,)}
>> (humour)(life)(friends)

{a|cut:10,''}
>> a long lon

a=[123, 345, 567]
{a|count:'item','items'}
>> 3 items

a=[123, 345, 567]
- kilo !countable
  en-US: kilogram, kilograms
  fr-FR: kilogramme, kilogrammes
{a|count:~kilo}
>> 3 kilograms

Filters can be chained:
a='appLes'
{a|lower|capital|singular|cut:10}
>> Apple

a=['humour', 'life', 'friends']
{a|wrap:(,)|join:'/'}
>> (humour)/(life)/(friends)

a='hello, world'
{a|wrap:*|textile}
>> <b>hello, world</b>

a='hello, world'
{a|split:' ',','|capital|join:/}
>> Hello/World

Filters can take variables as parameters:
a='long long long string'
max_length=10
{a|cut:max_length}
>> long lo...

Filters can walk through data:
a=[('apples', 11),('bananas', 32)]
{a|sum:(_,x), x}
>> 43

a=[{~apples: 11},{~bananas: 32}]
{a|sum:{_,x}, x}
>> 43

a=[[111, 222], [78, 20]]
{a|sum:[_,x], x}
>> 242

== i18n

It is possible to provide custom translations dictionary in the following format (YAML):
- apple !countable
  en-US: apple, apples
  fr-FR: pomme, pommes
- banana !countable
  en-US: banana, bananas
  fr-FR: banane, bananes

To set this as default translation used by retem:
Retem.i18n('apps/my_app/i18n.yaml')

Then, when calling
template = '{~apples}{~banana}'
Retem.render(template, {}, 'fr-FR')

Here we suggest that {apples|count:~apples} will be replaced with (assuming apples size is 3):
* "3 apples" for english ('en-US')
* "3 pommes" for french ('fr-FR')
* etc.

Retem uses 'en-US' as default unless otherwise requested.

== Nesting

It is possible to call external methods to provide nesting support.
Imagine we have a template 'home_page', and we want it to consist of several parts:

My mail
{nest ~mail}
My calendar
{nest ~calendar}
My contacts
{nest ~contacts}

In this case the feedback is called, and it is passed the nested atom and all the parameters.
With this it is possible to nest templates:

Retem.render(template, [{~apples: apples}]) do |nested_template, params| 
	Retem.render(get_template_by_name(nested_template), params) 

In this case, when retem sees a 'nest' statement, it calls the callback block and inserts
the result to itself. Of course, nested parts can have nested parts too.

== Authors
* Philpipp Pirozhkov pirj@mail.ru
