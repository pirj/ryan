= Templating with retem

Retem is a templating engine which comes with Ryan web framework for Reia programming
language.
It provides convenient syntax and a lot if features available out of the box:

* variables
* flow control
* filters
* i18n
* nesting of templates

== Building

== Usage

template = """Total {apples|count:~apples}
{for apple in apples} {apple.color apple.weight|kg} {end}"""
apples = [{~color: 'red', ~weight: 0.2}, {~color: 'yellow', ~weight: 0.15}]
renderer = Retem.new('apps/my_app/i18n.yaml')
renderer.render(template, {~apples: apples})
>> Total 2 apples
.. red 0.2kg
.. yellow 0.15kg

== Flow control

The simplest branching construct available is the if statement, which takes the specified branch if the condition holds true:

{if condition}
 ... 
{end}

Condition can consist of multiple conditions:

{if condition1 and condition2}...{end}
{if condition1 or condition2}...{end}

Condition can be a result of comparsion:
{if bees_count gt flowers_count}...{end}

The following comparsion operators can be used:

* eq  equal to
* neq not equal to
* gt greater than
* lt less than
* gteq greater than or equal to
* lteq less than or equal to

It is possible to use these kind of constructions:
{if a gt 3 or b lt 10}...{end}

The else keyword specifies an action to be taken if the condition doesn't match:

{if condition}
  ...
{else}
  ...
{end}

Multiple if statements can be chained with the elseif keyword:

{if condition1}
  ...
{elseif condition2}
  ...
{end}

This can be used with else, too:

{if condition1}
  ...
{elseif condition2}
  ...
{else}
  ...
{end}

The unless keyword functions like the if keyword, except expression matching is inverted and the branch is taken if the condition does not hold.

{unless condition}
  ...
{end}

For loops can iterate lists:

{for x in mylist}
  {x*2}
{end}

Pattern matching can be used when iterating lists of objects.
When iterating a list of lists:
mylist = [['aaa', 123], ['qqq', 456]]
{for [a,b] in mylist}
  {a} {b}
{end}

When iterating a list of tuples:
mylist = [('aaa', 123, ~first), ('qqq', 456, ~second)]
{for (a,b,c) in mylist}
  {a} {b} {c}
{end}

When iterating a list of dicts/objects:
apples = [{~color: 'red', ~weight: 0.2}, {~color: 'yellow', ~weight: 0.15}]
{for {color: ~color, weight: ~weight} in apples}
  Color is {color} and weight is {weight}
{end}

== Access to variables

Variables passed to retem can be freely used in templates:

{apple}

{apple.color}

{store.address.city}

== Filtering

Filtering allows for value modification, formatting etc. Filter signature comes after '|' character.
Filter parameters are passed after ':' character. Multiple parameters can be passed using ',' character.
For those parameters that can be treaten erratic, single quoting can be used.

The following examples are self-explaining, taking into account that a is a variable being passed:

a='apPles'
{a|capital}
>> ApPles

a='apPles AnD BaNaNas'
{a|capitalphrase}
>> Apples and bananas

a='apPles'
{a|lower}
>> apples

a='apPles'
{a|upper}
>> APPLES

a='app_les'
{a|pretty}
>> App les

a='apple'
{a|plural}
>> apples

a='apples'
{a|singular}
>> apple

a='apples'
{a|length}
>> 6

a=nil
{a|default:'none'}
>> none

a='*apple*'
{a|textile}
>> <b>apple</b>

a='/apple/'
{a|textile}
>> <i>apple</i>

a=123
{a|float:0,3}
>> 123.000

a=123
{a|float:4,3}
>> 0123.000

a=Time.now
{a|date:dd-MM-yy/hh:mm:ss}
>> 11-11-2008/02:31:14

a=Time.now - 100
{a|since:1}
>> 2 minutes

a=Time.now + 100
{a|until:2}
>> 1 minute, 40 seconds

a=1300000
{a|bytes:2}
>> 1,269.53KB

a=88005554567
{a|format:#-###-###-####}
>> 8-800-555-4567

a='8800call2me'
{a|format:#-###-#######}
>> 8-800-call2me

a='<h1>"Theory & practice"</h1>'
{a|escape}
>> &lt;h1&gt;&quot;Theory &amp; practice&quot;&lt;/h1&gt;

a='<h1>Theory</h1>'
{a|safe}
>> Theory

a='a long long long string'
{a|cut:15}
>> a long long ...
{a|cut:30}
>> a long long long string

a="""a long
long
string"""
{a|lines:0}
0 a long
1 long
2 string

a=['apple', 'banana', 'coconut']
{a|count}
>> 3

a=['humour', 'life', 'friends']
Tags: {a|join:' '}
>> Tags: humour life friends

Filters can take several parameters:
a=['humour', 'life', 'friends']
{a|wrap:(,)}
>> (humour)(life)(friends)

{a|cut:10,''}
>> a long lon

a=[123, 345, 567]
{a|count:'item','items'}
>> 3 items

a=[123, 345, 567]
- kilo !countable
  en-US: kilogram, kilograms
  fr-FR: kilogramme, kilogrammes
{a|count:~kilo}
>> 3 kilograms

Filters can be chained:
a='appLes'
{a|lower|capital|singular|cut:10}
>> Apple

a=['humour', 'life', 'friends']
{a|wrap:(,)|join:'/'}
>> (humour)/(life)/(friends)

a='hello, world'
{a|wrap:*|textile}
>> <b>hello, world</b>

a='hello, world'
{a|split:' ',','|capital|join:/}
>> Hello/World

Filters can take variables as parameters:
a='long long long string'
max_length=10
{a|cut:max_length}
>> long lo...

Filters can walk through data:
a=[('apples', 11),('bananas', 32)]
{a|sum:(_,x)}
>> 43

a=[{~apples: 11},{~bananas: 32}]
{a|sum:{_,x}}
>> 43

a=[[111, 222], [78, 20]]
{a|sum:[_,x]}
>> 242

== Extending filters with native code



== i18n

It is possible to provide custom translations dictionary in the following format (YAML):
apps/my_app/i18n.yaml:
- apple !countable
  en-US: apple, apples
  fr-FR: pomme, pommes
- banana !countable
  en-US: banana, bananas
  fr-FR: banane, bananes

Retem uses 'en-US' as default unless otherwise requested.
Dictionary is provided when creating retem instance:
renderer = Retem.new('apps/my_app/i18n.yaml')
renderer.render('{apples|count:~apples}', {~apples: 3})
>> 3 apples
renderer.render('{apples|count:~apples}', {~apples: 3}, 'fr-FR')
>> 3 pommes

== Nesting

It is possible to call external methods to provide nesting support.
Imagine we have a template 'home_page', and we want it to consist of several parts:

My mail
{nest ~mail}
My calendar
{nest ~calendar}
My contacts
{nest ~contacts}

In this case the feedback is called, and it is passed the nested atom and all the parameters.
With this it is possible to nest templates:

renderer=Retem.new()
renderer.render(template, {~apples: apples}) do |nested_template, params| 
	renderer.render(get_template_by_name(nested_template), params) 

In this case, when retem sees a 'nest' statement, it calls the callback block and inserts
the result to itself. Of course, nested parts can have nested parts too.

== Authors
* Philpipp Pirozhkov pirj@mail.ru
